search 命令用于搜索、过滤原始日志，search有两种用法：

* search 命令是spl管道的首个命令，用来筛选出需用其他 spl 命令进行分析的日志。

* search 命令可以用在管道符之后，进行搜索结果过滤，与where等价，如 ```* ｜ search * ```与 ```* ｜ where true``` 等价。


**语法：**

search `<logical-expression>`

### **1.语法介绍**

**search 用在搜索语句开头**

在 spl 语句的开头，通常会输入 search 命令搜索日志，但 search 关键词是可以省略的，如

```
search post=*
```

和

```
post=* 
```

是等价的。

在搜索时，若您搜索的数据包含以下符号，需要以双引号 "" 包含起来：

```
+  -  
&&  ||  !
( )  { }  [ ] 
^  ”  ~  *  ?  :  \
```

**search 用在管道符之后**

在管道符之后可以使用search进行搜索结果过滤，其效果等价于where。如

```* ｜ search * ```

和

``` * ｜ where true```

是等价的。

```* ｜ search  a>b ```

和

```* | where a>b```

是等价的。

注意：search 的两种用法编写规范一致。

#### **通过 search 命令指定绝对时间搜索范围**

通过指定 13 位毫秒级 Unix epoch 时间戳，来指定一个绝对时间。

示例：
``` sh 
search start=1575672371000 end=1577779610000
```

#### **通过 search 命令指定相对时间搜索范围**

相对时间，例如：昨天、前三天、上周、上个月等时间概念。

**相对时间语法快速入门**

假设执行搜索的时间为`2019年12月03日 19:05:43.567 星期二`，若在SPL中指定 `start=“-M@d-2h”`，其含义为：
* `-M`表示相对当前时间偏移到上个月。即偏移到`2019年11月03日 19:05:43.567`。
* `@d`表示时间对齐到天，意味着对齐年月日，而时分秒信息统统规整到`0`。因此，`@d`表示`2019年11月03日 00:00:00.000`
* `-2h`，表示在时间对齐之后，再次往前偏移2小时。因此，`-M@d-2h`表示`2019年11月02日 22:00:00.000`

因此指定 `start=“-M@d-2h”`的含义是：搜索从`2019年11月02日 22:00:00.000`到`2019年12月03日 19:05:43.567`的数据。

**时间单位说明**

|时间单位|时间单位符号|
|:--:|:--:|
|second|`s`|
|minute|`m`|
|hour|`h`|
|day|`d`|
|week|`w`|
|month|`M`|
|year|`y`|

**时间对齐符号说明**

|时间对齐符号|含义|
|:--:|:--:|
|`@ms`|对齐到毫秒（等同于不做任何处理。默认情况下，对齐到毫秒）|
|`@s`|对齐到秒（年月日时分秒信息与当前时间对齐，毫秒值规整为0）|
|`@m`|对齐到分钟（年月日时分信息与当前时间对齐，秒及毫秒规整为0）|
|`@h`|对齐到小时（年月日时信息与当前时间对齐，分秒及毫秒规整为0）|
|`@d`|对齐到天（年月日信息与当前时间对齐，时分秒及毫秒规整为0）|
|`@w`|对齐到周（年和星期将与当前时间对齐，确切地说，@w是对齐到一周的第一天的00:00:00。根据ISO 8601, 采用周一为每周的第一天，因此@w等同于@w1）|
|`@w1`|对齐到周一|
|`@w2`|对其到周二|
|`@w3`|对齐到周三|
|`@w4`|对齐到周四|
|`@w5`|对齐到周五|
|`@w6`|对齐到周六|
|`@w7`|对齐到周日
|`@M`|对齐到月（年月信息与当前时间对齐，日信息规整为1，时分秒及毫秒规整为0）|
|`@y`|对齐到年（年信息与当前时间对齐，月日信息规整为1，时分秒及毫秒规整为0）|

**更多用法示例**

 假设执行搜索的时间为2019年12月03日 19:05:43.567 星期二，即执行搜索的当前时间。
 
|SPL|搜索时间范围|含义|
|:--:|:--:|:--:|
|`start=0` | 1970-01-01 00:00:00.000~2019年12月03日 19:05:43.567 | 搜索所有时间 | 
| `start="-d@d" end="@d"`|2019年12月02日 00:00:00.000~2019年12月03日 00:00:00.000	|搜索昨天一整天的日志|
|`start="-d"`	|2019年12月02日 19:05:43.567~2019年12月03日 19:05:43.567	|搜索相对当前时间一天内的数据|
|`end="-d"`	|1970年01月01日 00:00:00.000~2019年12月02日 19:05:43.567	|搜索截止到昨天19:05:43.567的日志数据|
|`start="-5m"`	|2019年12月03日 19:00:43.567~2019年12月03日 19:05:43.567	|搜索前5分钟的日志|
|`start="-M@M" end="@M"`	|2019年11月01日 00:00:00.000~2019年12月01日 00:00:00.000	|搜索上个月的所有日志|
|`start="@M-1d" end="@M"`	|2019年11月30日 00:00:00.000~2019年12月01日 00:00:00.000	|搜索上个月最后一天的日志|
|`start="-w@w" end="@w"`	|2019年11月25日 00:00:00.000~2019年12月02日 00:00:00.000	|搜索上周的所有日志|
|`start="-w"`	|2019年11月26日 19:05:43.567~2019年12月03日 19:05:43.567	|搜索最近一周之内的所有日志|
|`start="-w@w1" end="-w@w6"`	|2019年11月25日 00:00:00.000~2019年11月30日 00:00:00.000	|搜索上周工作日的日志|
|`start="-2w@w6-2h" end="-2w@w6+2h"`	|2019年11月29日 22:00:00.000~2019年11月30日 02:00:00.000	|搜索上上周五晚上10点到上上周六凌晨2点之间4个小时的日志|

注意：

1.`start`, `end` 需放在 SPL 语句的最前方。形如：
``` sh 
 start="-3h" end="-2h" sourcetype="test_sourcetype"
 ```
否则，`start`，`end`将被视为日志中的一个字段处理。

2：`start`， `end` 所指定的时间区间是左闭右开的。例如
```
start="-3h" end="-2h" 
```
指定的时间是从前3小时（包括前3小时）到前2小时（不包括前2小时）

3：`start`， `end` 允许只填写其中之一，另一个缺省。
如：若指定`start`，但未指定`end`，那么`end`时间默认为当前系统时间+1毫秒）；
若指定了`end`，但未指定`start`，那么`start`默认为 0，即 `start` 时间为`1970-01-01 00:00:00.000`；
若`start`， `end`均未在 search 命令中指定，则将采用您在时间控件中的选择时间范围。

4：若 SPL 中存在子查询且子查询未指定 start 或 end 参数，那么子查询将优先采用其直属父查询（即最近的父查询）的搜索时间范围。若其直属父查询也未指定start，end，则继续向前寻找指定了 start，end 的父查询。若所有父查询都未指定 start 或 end，则将采用您在时间控件中的选择的时间范围。

示例一：
``` sh 
search start="-d@d" end="@d" | join [search start="-M@M" end="@M" | join [search ...]]
```
这是一个深层嵌套的`join`语句。第3层子查询没有指定`start`或`end`. 将采用距离其最近的，即第2层子查询的`start`， `end`

示例二：
``` sh 
search start="-d@d" end="@d"
| join [search start="-2d@d" end="@d"]
| join [search start="-2M@M" end="@M"]
| join [search ...]
```

最后一条`search`未指定`start`或`end`，将采用其直属父查询(最近的父查询)的`start`, `end`（即start="-d@d" end="@d"），且不会受到其他同级子查询`start`, `end`的影响

### **2.搜索说明**

1.在原始日志中搜索字符串，需指定完整的字符串内容。如：
原始日志中有短语 error ，需在搜索栏输入“error”，输入“e”、“erro”均无法搜到该条日志。

2.搜索字段，需指定完整的字段及值。如：

输入 type="error" 返回包含 type="error"的日志结果，输入 type=* 返回所有包含 type字段的结果，输入type="e"、type="erro"均无法搜到该条日志。

> 需注意，搜索加有引号的短语 "web error" 与不加引号时的搜索不同。搜索 web error 时，系统会返回包含"web" 和 "error" 的事件。搜索 "web error" 时，系统只返回包含短语 "web error" 的事件。

### **3.搜索条件编写规范**

搜索条件编写规范说明如下：

```
通配符: *
逻辑运算符: AND, OR, NOT, ( )
字段值完全匹配: apache.method="get"
字段值模糊匹配: apache.status=*
全文短语检索: "ACCESS DENIED" 
全文多关键词检索: ACCESS DENIED
字段数值范围: apache.status<=400 或 apache.status>400
字段值在列表中: apache.status in (200, 400)
简单正则表达式: /frontend[0-9]2/
```

详细语法规则的解释如下：

|名称|	语义|
|:-:|:-:|
|*	|查询所有内容|
|AND|	查询交集|
|OR|	查询并集|
|NOT	|查询不包括 NOT 子句的结果，如 NOT status:200 不包含 status 值为 200 的数据|
|in	|查询包含某个值的数据，如 status IN (400,500) 查询 status 值为 400或 500 的数据|
|()	|把一个或多个搜索语句合并成一个搜索语句，提升优先级，如 status IN (400,500) 查询 status 值为400或500 的数据|
|\|	转义字符，⽤于“转义”特定字符。如正则表达式搜索时表达式包含反斜杠的情况，如 `request_path=/\/query\/abc\/.*/` 查询 request_path 字段匹配正则表达式 `/query/abc/.*` 的数据
|>,=,<,<=,>=,!=	|区间查询，如 status:>=500 查询 status 大于 500 的数据|


#### **条件编写规范说明**

1.查询两个字符串的交集可省略 AND，即 query1 AND query2 等价于 query1 query2。
2.NOT 运算符仅适用于紧随 NOT 之后的字符串，若要查询排除多个字符串的结果，需写多个NOT 子句并将其用AND连接。如：NOT query1 AND NOT query2。

**通配符查询**

1.使用 ? 代替一个字符， * 代替0或者多个字符。

比如：
```
type=qu?ck type=bro*
```
> 注意使用这个查询会消耗大量资源，并且速度会降低。

**正则表达式查询**

正则表达式查询条件编写时，以""开头和结尾。

比如：
```
name=/joh?n(ath[oa]n)/
```

>需注意，正则表达式中使用管道符 | 来表达 OR 条件。例如， A或B 的表达式为 A|B。由于管道符在 SPL 中⽤于分隔命令，正则表达式中用到管道符时，需用“”括起来。

### **4.查询举例**

字段 name ，值等于 a 的记录：
```
name="a"
```

字段 ip ，内容等于 a 或 b 的记录：
```
ip in ("a", "b") 
```

字段 hosts ，等于 a 或者 b ，且不等于 c 的记录：
```
hosts in (a,b)  AND (NOT hosts="c")
```

字段 ip ，等于 a 或 b ，同时字段 hosts ，内容等于 c 的记录：
```
ip in (a, b, c) AND (hosts="c")
```

字段 count ，值大于 5 的记录： 
```
count>=5
```


