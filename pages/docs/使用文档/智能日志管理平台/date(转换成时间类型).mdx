对指定的 key 转换为指定的时间格式，这个 key 里面存的实际值可以是一个字符串，也可以是一个 timestamp 数字。


![](https://dn-odum9helk.qbox.me/Fo5iecqm_MArbkEcVasTmglc2H7J)

在0.2.2及以后版本，默认如果时间字符串没有带上时区，会以logkit-pro所在机器的时区为准解析用户时间，也就是如果logkit-pro所在时区是东八区，而时间字符串为`2018-01-02T15:04:05`,会默认变为`2018-01-02T15:04:05Z08:00`解析，在0.2.1及以前版本则没有这个假设，没有时区还是以UTC时间解析。

* 要进行Transform变化的键(`key`): 支持多级嵌套，多级间用 *.* 符号连接，如 abc.xyz，表示 data["abc"]["xyz"]中的数据。

* 时区偏移量(offset): 如果key中带有时区信息，则以该时区作为offset的基础时区，否则以UTC时区为基础时区。 在0.2.1及以前版本中，该选项通常用来对时间进行变换，如解析的时间没有带时区，被默认作为了 UTC 时间，但是又想变换为东八区时间，这样就只要在 Offset 处设置为 -8 即可。0.2.2及以后版本默认用不到，但是对时间有特殊偏移需求的用户可以用该功能。

* 时间样式(`time_layout_before`): 设置自己的时间类型的样式，在你的数据无法自动解析的情况下，可以通过这个参数设置。默认情况下无需填写，系统会自动解析。

* 解析后时间样式(`time_layout_after`): 设置解析后的时间，Pandora接受的时间类型(date)类型本质上是 RFC3339 的字符串，所以此处如果不填，默认转为RFC3339的字符串，也可根据需要转为其他样式。

### **时间格式(layout)的写法**

时间格式的写法符合 golang 的时间格式定义方法，具体参见[https://golang.org/pkg/time/#pkg-constants](https://golang.org/pkg/time/#pkg-constants)类似如下。

```
ANSIC     = "Mon Jan _2 15:04:05 2006"
UnixDate    = "Mon Jan _2 15:04:05 MST 2006"
RubyDate    = "Mon Jan 02 15:04:05 -0700 2006"
RFC822      = "02 Jan 06 15:04 MST"
RFC822Z     = "02 Jan 06 15:04 -0700" // RFC822 with numeric zone
RFC850      = "Monday, 02-Jan-06 15:04:05 MST"
RFC1123     = "Mon, 02 Jan 2006 15:04:05 MST"
RFC1123Z    = "Mon, 02 Jan 2006 15:04:05 -0700" // RFC1123 with numeric zone
RFC3339     = "2006-01-02T15:04:05Z07:00"
RFC3339Nano = "2006-01-02T15:04:05.999999999Z07:00"
Kitchen     = "3:04PM"
// Handy time stamps.
Stamp      = "Jan _2 15:04:05"
StampMilli = "Jan _2 15:04:05.000"
StampMicro = "Jan _2 15:04:05.000000"
StampNano  = "Jan _2 15:04:05.000000000"
```

简单来说，年份必须是 2006，月份必须是 1 或者 Jan，日必须是 2, 时必须是 3(两位数必须是 15,一位数时后面要跟 PM,类似 Kitchen 的描述)，分必须是 4,秒必须是 5，时区必须是 +7。比如 RFC3339 的格式定义为2006-01-02T15:04:05+07:00，又或者我们自己定义一个简单版的时间 2006|01|02|03|04|05，年月日时分秒分别用竖线|分隔，假设当前时间为 2017 年 6 月 6 日 20 时 38 分 12 秒，则按我们定义的格式显示为 2017|06|06|20|38|12。