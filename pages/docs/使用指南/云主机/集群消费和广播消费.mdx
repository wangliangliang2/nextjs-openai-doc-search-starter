本文主要介绍消息队列 RocketMQ 的集群消费和广播消费的基本概念，适用场景以及注意事项。
# 基本概念

消息队列 RocketMQ 是基于发布/订阅模型的消息系统。消息的订阅方订阅关注的 Topic，以获取并消费消息。由于订阅方应用一般是分布式系统，以集群方式部署有多台机器。因此消息队列 RocketMQ 约定以下概念。
- 集群：使用相同 Group ID 的订阅者属于同一个集群。同一个集群下的订阅者消费逻辑必须完全一致（包括 Tag 的使用），这些订阅者在逻辑上可以认为是一个消费节点。
- 集群消费：当使用集群消费模式时，消息队列 RocketMQ 认为任意一条消息只需要被集群内的任意一个消费者处理即可。
- 广播消费：当使用广播消费模式时，消息队列 RocketMQ 会将每条消息推送给集群内所有注册过的客户端，保证消息至少被每台机器消费一次。

# 场景对比

## 集群消费模式：
![](https://dn-odum9helk.qbox.me/Fp1uHXuC9c0e3sNTkR8uf9kARtXF)
**适用场景&注意事项**
- 消费端集群化部署，每条消息只需要被处理一次。
- 由于消费进度在服务端维护，可靠性更高。
- 集群消费模式下，每一条消息都只会被分发到一台机器上处理。如果需要被集群下的每一台机器都处理，请使用广播模式。
- 集群消费模式下，不保证每一次失败重投的消息路由到同一台机器上，因此处理消息时不应该做任何确定性假设。

## 广播消费模式：
![](https://dn-odum9helk.qbox.me/FkoIClyIO7ZgxbpEIzYfPcT5_8CB)
**适用场景&注意事项**
- 广播消费模式下不支持顺序消息。
- 广播消费模式下不支持重置消费位点。
- 每条消息都需要被相同逻辑的多台机器处理。
- 消费进度在客户端维护，出现重复的概率稍大于集群模式。
- 广播模式下，消息队列 RocketMQ 保证每条消息至少被每台客户端消费一次，但是并不会对消费失败的消息进行失败重投，因此业务方需要关注消费失败的情况。
- 广播模式下，客户端每一次重启都会从最新消息消费。客户端在被停止期间发送至服务端的消息将会被自动跳过，请谨慎选择。
- 广播模式下，每条消息都会被大量的客户端重复处理，因此推荐尽可能使用集群模式。
- 广播模式下服务端不维护消费进度，所以消息队列 RocketMQ 控制台不支持消息堆积查询、消息堆积报警和订阅关系查询功能。

## 使用集群模式模拟广播：
如果业务需要使用广播模式，也可以创建多个 Group ID，用于订阅同一个 Topic。
![](https://dn-odum9helk.qbox.me/FiywI-VJEWkv1tBlMtAmCEx51C6i)
**适用场景&注意事项**
- 每条消息都需要被多台机器处理，每台机器的逻辑可以相同也可以不一样。
- 消费进度在服务端维护，可靠性高于广播模式。
- 对于一个 Group ID 来说，可以部署一个消费端实例，也可以部署多个消费端实例。 当部署多个消费端实例时，实例之间又组成了集群模式（共同分担消费消息）。 假设 Group ID 1 部署了三个消费者实例 C1、C2、C3，那么这三个实例将共同分担服务器发送给 Group ID 1 的消息。 同时，实例之间订阅关系必须保持一致。

# 示例代码
示例代码请参见以下文档：
- Java：[订阅消息](https://developer.qiniu.io/qvm/manual/6142/subscribe-to-news)
- .NET：[订阅消息](https://developer.qiniu.io/qvm/manual/6145/RocketMQ-C-subscribe-to-news)
- C/C++：[订阅消息](https://developer.qiniu.io/qvm/manual/6149/NET-subscribe-to-news)